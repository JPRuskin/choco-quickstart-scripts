name: Test Deployment

on:
  workflow_dispatch:
    inputs:
      ignore_cache:
        description: Does not restore a package cache if selected.
        required: false
        type: boolean

      vm_size:
        description: The size of VM to spin up.
        default: Standard_B4ms # Standard_B4as_v2

  pull_request:
    paths:
      - files/**.json
      - '*.ps1'
      - scripts/**.ps1
    types:
      ready_for_review

  pull_request_review:
    types:
      - submitted

# May want to remove this, as though it's neat to only have one job running per 
# ref, it may cancel before cleanup has happened.
# concurrency:
#   group: ${{ github.workflow }}-${{ github.ref }}
#  cancel-in-progress: true

defaults:
  run:
    shell: pwsh

jobs:
  matrix:
    name: Generate Testing Parameters
    runs-on: ubuntu-latest
    steps:
      - name: Generate Test Matrix
        id: test-matrix
        shell: pwsh
        run: |
          $EventType = '${{ github.event_name }}'
          $AuthHeaders = @{Headers = @{Authorization = 'Bearer ${{ secrets.GITHUB_TOKEN }}'}}
          $GitHubApi = '${{ github.api_url }}'
          switch ($EventType) {
            'workflow_dispatch' {
              # We have been triggered manually. Run it all!
              $Images = "Win2022AzureEditionCore", "Win2019Datacenter"
              $Variants = "selfsigned", "single", "wildcard"
            }
            'pull_request' {
              # This is a pull request. If it's from a known maintainer, run a fast test - otherwise, exit.
              $TriggerPermission = Invoke-RestMethod "$GitHubApi/repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission" @AuthHeaders

              if ($TriggerPermission -in @("admin", "write")) {
                $Images = "Win2022AzureEditionCore"
                $Variants = "selfsigned"
              } else {
                Write-Error "Action was triggered by '${{ github.actor }}', who has '$TriggerPermission': Cancelling build."
                exit 1
              }
            }
            'pull_request_review' {
              # This is a review. If it's positive, run tests - otherwise, exit.
              $TriggerPermission = Invoke-RestMethod "$GitHubApi/repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission" @AuthHeaders

              if ($TriggerPermission -in @("admin", "write")) {
                $Images = "Win2022AzureEditionCore", "Win2019Datacenter"
                $Variants = "selfsigned", "single", "wildcard"
              } else {
               Write-Error "Action was triggered by '${{ github.actor }}', who has '$TriggerPermission': Cancelling build."
                exit 1
              }
            }
          }
          "images=$($Images | ConvertTo-Json -Compress -AsArray)" >> $env:GITHUB_OUTPUT
          "variants=$($Variants | ConvertTo-Json -Compress -AsArray)" >> $env:GITHUB_OUTPUT

    outputs:
      matrix-os: ${{ steps.test-matrix.outputs.images }}
      matrix-variant: ${{ steps.test-matrix.outputs.variants }}

  build:
    name: Build Package Cache
    runs-on: windows-latest
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Create License File
        run: |
          if (-not (Test-Path C:\choco-setup\files)) {
            New-Item -Path C:\choco-setup\files -ItemType Junction -Value $PWD.Path
          }
          $LicenseDir = Join-Path $env:ChocolateyInstall 'license'
          if (-not (Test-Path $LicenseDir)) {$null = mkdir $LicenseDir}
          Set-Content -Path $LicenseDir\chocolatey.license.xml -Value $(
            [System.Text.Encoding]::UTF8.GetString(
              [System.Convert]::FromBase64String('${{ secrets.LICENSE }}')
            )
          )

      - name: Setup Package Cache
        uses: actions/cache@v4
        if: inputs.ignore_cache != true
        with:
          path: |
            C:/choco-setup/files/files/*.nupkg
            C:/choco-setup/files/files/*.zip
            !**/chocolatey-license.*.nupkg
          key: "${{ hashFiles('files/*.json') }}"

      - name: Begin Setup
        run: C:\choco-setup\files\OfflineInstallPreparation.ps1

      - name: Upload Built Artifact
        id: build-upload
        uses: actions/upload-artifact@v4
        with:
          name: choco-packages
          path: |
            C:\choco-setup\files\*
            !C:\choco-setup\files\.git*
            !chocolatey-license.*.nupkg
            !C:\choco-setup\files\files\chocolatey.license.xml

    outputs:
      artifact-url: ${{ steps.build-upload.outputs.artifact-url }}

  runner_test_deploy:
    strategy:
      matrix:
        os: ${{ fromJson(needs.matrix.outputs.matrix-os) }}
        variant: ${{ fromJson(needs.matrix.outputs.matrix-variant) }}
      fail-fast: false
    name: Test ${{ matrix.os }} with ${{ matrix.variant }}
    runs-on: windows-latest
    needs: [build, matrix]
    if: success()
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Deploy '${{ matrix.os }}' VM
        id: deploy-vm
        uses: azure/powershell@v2
        with:
          inlineScript: |
            Import-Module .\.github\workflows\Helpers.psm1

            $Location = 'eastus2'
            $ResourceGroupName = "qsg-testing"
            if ('${{ github.run_id }}' -ne "`$`{{ github.run_id }}") {$ResourceGroupName += '-${{ github.run_id }}'}

            if (-not (Get-AzResourceGroup -ResourceGroupName $ResourceGroupName -ErrorAction SilentlyContinue)) {
              $null = New-AzResourceGroup -ResourceGroupName $ResourceGroupName -Location $Location -Force
            }

            $VM = New-TestVM -ResourceGroupName $ResourceGroupName -Image '${{ matrix.os }}' -Size '${{ inputs.vm_size }}'

            # Set NSG to have access
            Request-WinRmAccessForTesting -ResourceGroupName $ResourceGroupName -VmName $VM.Name

            Write-Host "Creating remoting session for $($VM.Credential.UserName)@$($Vm.FullyQualifiedDomainName)"
            $RemotingArgs = @{
              ComputerName = $VM.FullyQualifiedDomainName
              Credential = $VM.Credential
              UseSSL = $true
              SessionOption = New-PSSessionOption -SkipCACheck -SkipCNCheck
            }
            $Session = New-PSSession @RemotingArgs

            # This throws an error when the session terminates, so we catch the PSRemotingTransportException 
            try {
              $HoplessSession = Invoke-Command -Session $Session {
                Register-PSSessionConfiguration -Name "Hopless" -RunAsCredential $using:VM.Credential -Force
              } -ErrorAction Stop
            } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {}

            Start-Sleep -Seconds 30  # Hate this, but just testing the idea out.

            Write-Verbose "Recreating Session after WinRM restart..."
            $Timeout = [System.Diagnostics.Stopwatch]::StartNew()
            while ($Session.Availability -ne 'Available' -and $Timeout.Elapsed.TotalSeconds -lt 180) {
              try {
                $Session = New-PSSession @RemotingArgs -ConfigurationName 'Hopless'
              } catch {
                Start-Sleep -Seconds 5
              }
            }

            if ($Session.Availability -ne 'Available') {
              $Session
              Write-Error "Failed to re-establish a connection to '$($Vm.FullyQualifiedDomainName)'"
            } else {
              Write-Host "Successfully reconnected after '$($Timeout.Elapsed.TotalSeconds)' seconds" 
            }

            # Install Dotnet 4.8 if required
            $RequiresDotnet = Invoke-Command -Session $Session -ScriptBlock {
              (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" -ErrorAction SilentlyContinue).Release -lt 528040
            }

            if ($RequiresDotnet) {
              Write-Host "Installing Dotnet 4.8 to '$($Vm.FullyQualifiedDomainName)'"
              $DotnetInstall = Invoke-Command -Session $Session -ScriptBlock {
                $NetFx48Url = 'https://download.visualstudio.microsoft.com/download/pr/2d6bb6b2-226a-4baa-bdec-798822606ff1/8494001c276a4b96804cde7829c04d7f/ndp48-x86-x64-allos-enu.exe'
                $NetFx48Path = $env:TEMP
                $NetFx48InstallerFile = 'ndp48-x86-x64-allos-enu.exe'
                $NetFx48Installer = Join-Path $NetFx48Path $NetFx48InstallerFile
                if (!(Test-Path $NetFx48Installer)) {
                  Write-Host "Downloading `'$NetFx48Url`' to `'$NetFx48Installer`'"
                  (New-Object Net.WebClient).DownloadFile("$NetFx48Url","$NetFx48Installer")
                }

                $psi = New-Object System.Diagnostics.ProcessStartInfo
                $psi.WorkingDirectory = "$NetFx48Path"
                $psi.FileName = "$NetFx48InstallerFile"
                $psi.Arguments = "/q /norestart"

                Write-Host "Installing `'$NetFx48Installer`'"
                $s = [System.Diagnostics.Process]::Start($psi);
                $s.WaitForExit();

                return $s.ExitCode
              }

              if ($DotnetInstall -eq 1641 -or $DotnetInstall -eq 3010) {
                Write-Host ".NET Framework 4.8 was installed, but a reboot is required before using Chocolatey CLI."
                $Reboot = Restart-AzVm -ResourceGroupName $ResourceGroupName -Name $VM.Name
                if ($Reboot.Status -eq 'Succeeded') {
                  Write-Host "Reboot was successful after $($Reboot.Endtime - $Reboot.Starttime)"
                }

                # Recreate the session
                $Session = New-PSSession @RemotingArgs -ConfigurationName 'Hopless'
              }
            }

            try {
              $DownloadUrl = if ('${{ needs.build.outputs.artifact-url }}' -match 'https://github.com/(?<Owner>.+)/(?<Repository>.+)/actions/runs/(?<RunId>\d+)/artifacts/(?<ArtifactId>\d+)') {
                "https://api.github.com/repos/$($Matches.Owner)/$($Matches.Repository)/actions/artifacts/$($Matches.ArtifactId)/zip"
              } else {
                '${{ needs.build.outputs.artifact-url }}'
              }
              Write-Host "Downloading Build Artifact '$DownloadUrl' to '$($VM.Name)' @$(Get-Date -Format o)"
              Invoke-Command -Session $Session -ScriptBlock {
                if (-not (Test-Path C:\choco-setup\files)) {$null = mkdir C:\choco-setup\files -Force}
                $ProgressPreference = "SilentlyContinue"
                $Response = Invoke-WebRequest -Uri $using:DownloadUrl -UseBasicParsing -Headers @{
                  Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                  Accept = "application/vnd.github+json"
                  "X-GitHub-Api-Version" = "2022-11-28"
                } -OutFile C:\choco-setup\files.zip
                Expand-Archive -Path C:\choco-setup\files.zip -DestinationPath C:\choco-setup\files\
              }
            } finally {
              Write-Host "Finished Downloading @$(Get-Date -Format o)"
            }

            Write-Host "Creating License File on '$($VM.Name)'"
            Invoke-Command -Session $Session -ScriptBlock {
              Set-Content -Path C:\choco-setup\files\files\chocolatey.license.xml -Value $(
                [System.Text.Encoding]::UTF8.GetString(
                  [System.Convert]::FromBase64String('${{ secrets.LICENSE }}')
                )
              )
            }

            Write-Host "Setting up '${{ matrix.variant }}' Certificate"
            $Certificate = switch ('${{ matrix.variant }}') {
              'selfsigned' {
                Write-Host "Creating a Self-Signed Certificate for '$($Vm.FullyQualifiedDomainName)'"
                @{Hostname = $Vm.FullyQualifiedDomainName}
              }
              'single' {
                $Thumbprint = Invoke-Command -Session $Session -ScriptBlock {
                  $Cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                    [Convert]::FromBase64String('${{ secrets.SINGLE_CERT }}'),
                    (ConvertTo-SecureString '${{ secrets.SINGLE_PASS }}' -AsPlainText -Force)
                  )

                  $Store = [System.Security.Cryptography.X509Certificates.X509Store]::new("My", "LocalMachine")
                  $Store.Open("ReadWrite")
                  $Store.Add($Cert)

                  $Cert.Thumbprint
                }
                Write-Host "Using Certificate with Thumbprint '$($Thumbprint)'"
                @{Thumbprint = $Thumbprint; Hardened = $true}
              }
              'wildcard' {
                $Thumbprint = Invoke-Command -Session $Session -ScriptBlock {
                  $Cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
                    [Convert]::FromBase64String('${{ secrets.WILDCARD_CERT }}'),
                    (ConvertTo-SecureString '${{ secrets.WILDCARD_PASS }}' -AsPlainText -Force)
                  )

                  $Store = [System.Security.Cryptography.X509Certificates.X509Store]::new("My", "LocalMachine")
                  $Store.Open("ReadWrite")
                  $Store.Add($Cert)

                  $Cert.Thumbprint
                }
                Write-Host "Using Wildcard with Thumbprint '$($Thumbprint)'"
                @{Thumbprint = $Thumbprint; CertificateDnsName = $Vm.FullyQualifiedDomainName; Hardened = $true}
              }
            }

            try {
              Write-Host "Installing QuickStart Guide on '$($VM.Name)'"
              $DatabaseCredential = [PSCredential]::new(
                'ccmdbuser',
                (ConvertTo-SecureString "$(New-Guid)" -AsPlainText -Force)
              )
              $Timer = [System.Diagnostics.Stopwatch]::StartNew()
              Invoke-Command -Session $Session -ScriptBlock {
                C:\choco-setup\files\Start-C4bSetup.ps1
                C:\choco-setup\files\Start-C4BNexusSetup.ps1
                C:\choco-setup\files\Start-C4bCcmSetup.ps1 -DatabaseCredential $using:DatabaseCredential
                C:\choco-setup\files\Start-C4bJenkinsSetup.ps1
                C:\choco-setup\files\Set-SslSecurity.ps1 @using:Certificate
              }
              $Timer.Stop()
              "deployment-time=$($Timer.Elapsed)" >> $env:GITHUB_OUTPUT

              # Run Tests
              Write-Host "Running Verification Tests on '$($VM.Name)'"
              $TestResults = Invoke-Command -Session $Session -ScriptBlock {
                if (-not (Get-Module Pester -ListAvailable).Where{$_.Version -gt "5.0"}) {
                  Write-Host "Installing Pester 5 to run validation tests"
                  $chocoArgs = @('install', 'pester', '-y', '--source="https://community.chocolatey.org/api/v2/"')
                  & choco @chocoArgs | Write-Host
                }
                (Get-ChildItem C:\choco-setup\files\tests\ -Recurse -Filter *.tests.ps1).Fullname
              } | ForEach-Object {
                Invoke-Command @RemotingArgs -ScriptBlock {
                  param(
                    $Path
                  )
                  . C:\choco-setup\files\scripts\Get-Helpers.ps1
                  $configuration = New-PesterConfiguration @{
                    Run        = @{
                      Container = New-PesterContainer -Path $Path -Data @{ Fqdn = $env:ComputerName }
                      Passthru  = $true
                    }
                    Output     = @{
                      Verbosity = 'Detailed'
                    }
                    TestResult = @{
                      Enabled      = $true
                      OutputFormat = 'NUnitXml'
                      OutputPath   = "C:\choco-setup\test-results\$((Split-Path $Path -Leaf) -replace '.tests.ps1$')-verification.results.xml"
                    }
                  }

                  Invoke-Pester -Configuration $configuration
                } -ArgumentList $_
              }
            } finally {
              Write-Host "Copying Results from '$($VM.Name)' @$(Get-Date -Format o)"
              if (-not (Test-Path .\logs\ -PathType Container)) {$null = mkdir .\logs\}
              Copy-Item -FromSession $Session -Path C:\choco-setup\logs\* -Destination .\logs\ -ErrorAction SilentlyContinue
              Copy-Item -FromSession $Session -Path C:\choco-setup\test-results\* -Destination .\logs\ -ErrorAction SilentlyContinue
            }
          azPSVersion: latest

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action/windows@v2
        if: success()
        with:
          check_name: C4bVerification-${{ matrix.os }}-${{ matrix.variant }}
          files: |
            logs\*-verification.results.xml
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish Log Files
        uses: actions/upload-artifact@v4
        if: success() || failure()
        with:
          name: choco-setup-logs-${{ matrix.os }}-${{ matrix.variant }}
          path: logs\*.txt

  cleanup:
    name: Cleanup Test Resources
    runs-on: ubuntu-latest
    needs: runner_test_deploy
    if: success() || failure()
    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Destroy Remaining Resources
        uses: azure/powershell@v2
        with:
          inlineScript: |
            $ResourceGroupName = "qsg-testing"
            if ('${{ github.run_id }}' -ne "`$`{{ github.run_id }}") {$ResourceGroupName += '-${{ github.run_id }}'}
            if (Get-AzResourceGroup -ResourceGroupName $ResourceGroupName -ErrorAction SilentlyContinue) {
              Remove-AzResourceGroup -ResourceGroupName $ResourceGroupName -Force  # -AsJob
            }
          azPSVersion: latest
